// Package cocktailsapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package cocktailsapi

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	Oauth2Scopes = "oauth2.Scopes"
)

// CocktailImageModel defines model for CocktailImageModel.
type CocktailImageModel struct {
	// Height The height of the image
	Height int32 `json:"height"`

	// Uri The uri of the image
	Uri string `json:"uri"`

	// Width The width of the image
	Width int32 `json:"width"`
}

// CocktailIngredientFiltersRs defines model for CocktailIngredientFiltersRs.
type CocktailIngredientFiltersRs struct {
	// BeerWineChampagne The cocktail ingredient filters for searching against beers, wines and champagnes
	BeerWineChampagne []interface{} `json:"beerWineChampagne"`

	// Bitters The cocktail ingredient filters for searching against bitters
	Bitters []interface{} `json:"bitters"`

	// Dilutions The cocktail ingredient filters for searching against dilutions
	Dilutions []interface{} `json:"dilutions"`

	// Eras The cocktail ingredient filters for searching against eras when cocktails were established
	Eras []interface{} `json:"eras"`

	// Fruits The cocktail ingredient filters for searching against friuts
	Fruits []interface{} `json:"fruits"`

	// Glassware The cocktail ingredient filters for searching against recommended glassware
	Glassware []IngredientFilterModel `json:"glassware"`

	// HerbsAndFlowers The cocktail ingredient filters for searching against herbs and flowers
	HerbsAndFlowers []interface{} `json:"herbsAndFlowers"`

	// Juices The cocktail ingredient filters for searching against juices
	Juices []interface{} `json:"juices"`

	// Liqueurs The cocktail ingredient filters for searching against liqueurs
	Liqueurs []interface{} `json:"liqueurs"`

	// Proteins The cocktail ingredient filters for searching against proteins
	Proteins []interface{} `json:"proteins"`

	// Spirits The cocktail ingredient filters for searching against spirits
	Spirits []interface{} `json:"spirits"`

	// SyrupsAndSauces The cocktail ingredient filters for searching against syrups and sauces
	SyrupsAndSauces []interface{} `json:"syrupsAndSauces"`

	// Vegetables The cocktail ingredient filters for searching against vegetables
	Vegetables []interface{} `json:"vegetables"`
}

// CocktailKeywordsModel The keywords associated with the cocktail recipe
type CocktailKeywordsModel struct {
	// KeywordsBaseSpirit Base spirit keywords
	KeywordsBaseSpirit []string `json:"keywordsBaseSpirit"`

	// KeywordsCocktailFamily Cocktail family keywords
	KeywordsCocktailFamily []string `json:"keywordsCocktailFamily"`

	// KeywordsFlavorProfile Flavor profile keywords
	KeywordsFlavorProfile []string `json:"keywordsFlavorProfile"`

	// KeywordsMood Mood keywords
	KeywordsMood []string `json:"keywordsMood"`

	// KeywordsOccasion Occasion keywords
	KeywordsOccasion []string `json:"keywordsOccasion"`

	// KeywordsSearchTerms Search terms keywords
	KeywordsSearchTerms []string `json:"keywordsSearchTerms"`

	// KeywordsSeason Season keywords
	KeywordsSeason []string `json:"keywordsSeason"`

	// KeywordsSpiritSubtype Spirit subtype keywords
	KeywordsSpiritSubtype []string `json:"keywordsSpiritSubtype"`

	// KeywordsStrength Strength keyword
	KeywordsStrength string `json:"keywordsStrength"`

	// KeywordsTechnique Technique keywords
	KeywordsTechnique []string `json:"keywordsTechnique"`

	// KeywordsTemperature Temperature keyword
	KeywordsTemperature string `json:"keywordsTemperature"`
}

// CocktailModel The cocktail recipe model
type CocktailModel struct {
	// Content The complete descriptive cocktail recipe including ingredients, directions and historical information in markdown format
	Content string `json:"content"`

	// Description A brief editorial description for the cocktail recipe
	Description string `json:"description"`

	// DescriptiveTitle A more descriptive title for the cocktail recipe, generally used as an editorial title
	DescriptiveTitle string `json:"descriptiveTitle"`

	// Glassware The recommended glassware to use when serving the cocktail
	Glassware []GlasswareTypeModel `json:"glassware"`

	// Id The cocktail recipe unique identifier
	Id string `json:"id"`

	// Ingredients The list of ingredients that make up the cocktail recipe
	Ingredients []IngredientModel `json:"ingredients"`

	// Instructions The list of instructions to make the cocktail recipe
	Instructions []InstructionStepModel `json:"instructions"`

	// IsIba Whether or not the cocktail represented by this recipe is recognized by the International Bartenders Association
	IsIba bool `json:"isIba"`

	// Keywords The keywords associated with the cocktail recipe
	Keywords CocktailKeywordsModel `json:"keywords"`

	// MainImages A list of primary images for the cocktail recipe
	MainImages []CocktailImageModel `json:"mainImages"`

	// ModifiedOn The date this cocktail recipe was last modified on Cezzis.Com
	ModifiedOn time.Time `json:"modifiedOn"`

	// PrepTimeMinutes The average number of minutes to build the cocktail using this recipe
	PrepTimeMinutes int32 `json:"prepTimeMinutes"`

	// PublishedOn The date this cocktail recipe was published on Cezzis.Com
	PublishedOn time.Time `json:"publishedOn"`

	// Rating A ratings for this cocktail
	Rating CocktailRatingModel `json:"rating"`

	// SearchTiles A list of secondary, smaller sized images for the cocktail recipe
	SearchTiles []interface{} `json:"searchTiles"`

	// SearchableTitles A list of titles that are queried against when issuing cocktail recipe search queries
	SearchableTitles []string `json:"searchableTitles"`

	// Serves The number of people the cocktail recipe serves
	Serves int32 `json:"serves"`

	// Tags A list of taxonomy tags defining the cocktail recipe
	Tags []string `json:"tags"`

	// Title The name of the cocktail recipe
	Title string `json:"title"`
}

// CocktailRatingModel A ratings for this cocktail
type CocktailRatingModel struct {
	// FiveStars The number of five star ratings
	FiveStars int32 `json:"fiveStars"`

	// FourStars The number of four star ratings
	FourStars int32 `json:"fourStars"`

	// OneStars The number of one star ratings
	OneStars int32 `json:"oneStars"`

	// Rating The actual overal rating
	Rating float64 `json:"rating"`

	// RatingCount The total number of ratings given
	RatingCount int32 `json:"ratingCount"`

	// ThreeStars The number of three star ratings
	ThreeStars int32 `json:"threeStars"`

	// TotalStars The total number of stars given
	TotalStars int32 `json:"totalStars"`

	// TwoStars The number of two star ratings
	TwoStars int32 `json:"twoStars"`
}

// CocktailRs defines model for CocktailRs.
type CocktailRs struct {
	// Item The cocktail recipe model
	Item CocktailModel `json:"item"`
}

// DocumentFormat The format that the document content is in
type DocumentFormat = interface{}

// GlasswareTypeModel defines model for GlasswareTypeModel.
type GlasswareTypeModel = interface{}

// IngredientApplicationModel defines model for IngredientApplicationModel.
type IngredientApplicationModel = interface{}

// IngredientFilterModel defines model for IngredientFilterModel.
type IngredientFilterModel struct {
	// Id The filter identifier
	Id string `json:"id"`

	// Name The display name of the filter
	Name string `json:"name"`
}

// IngredientModel defines model for IngredientModel.
type IngredientModel struct {
	// Applications The ingredient applications that this ingredient is in relation to the cocktail recipe
	Applications []IngredientApplicationModel `json:"applications"`

	// Display Gets the complete display value for the ingredient including units and measurments
	Display string `json:"display"`

	// Name The name of the ingredient
	Name string `json:"name"`

	// Preparation Any preparation that should be made with this ingredient
	Preparation PreparationTypeModel `json:"preparation"`

	// Requirement Whether or not this ingredient is required ('Required' or 'Optional')
	Requirement IngredientRequirementTypeModel `json:"requirement"`

	// Suggestions Suggestion when using this ingredient
	Suggestions string `json:"suggestions"`

	// Types The ingredient types that this ingredient is in relation to the cocktail recipe
	Types []IngredientTypeModel `json:"types"`

	// Units The number of units to use in relation to the UoM (unit of measure) in the cocktail recipe
	Units float32 `json:"units"`

	// UoM The unit of measure when using this ingredient in a cocktail recipe
	UoM UofMTypeModel `json:"uoM"`
}

// IngredientRequirementTypeModel Whether or not this ingredient is required ('Required' or 'Optional')
type IngredientRequirementTypeModel = interface{}

// IngredientTypeModel defines model for IngredientTypeModel.
type IngredientTypeModel = interface{}

// InstructionStepModel defines model for InstructionStepModel.
type InstructionStepModel struct {
	// Display The displayable value for the instruction step
	Display string `json:"display"`

	// Order The order of the instruction step in which it should be performed
	Order int32 `json:"order"`
}

// LegalDocumentRs defines model for LegalDocumentRs.
type LegalDocumentRs struct {
	// Document The document content
	Document string `json:"document"`

	// Format The format that the document content is in
	Format DocumentFormat `json:"format"`
}

// PreparationTypeModel Any preparation that should be made with this ingredient
type PreparationTypeModel = interface{}

// ProblemDetails defines model for ProblemDetails.
type ProblemDetails struct {
	Detail   *string `json:"detail"`
	Instance *string `json:"instance"`
	Status   *int32  `json:"status"`
	Title    *string `json:"title"`
	Type     *string `json:"type"`
}

// PublishCocktailsRq defines model for PublishCocktailsRq.
type PublishCocktailsRq struct {
	// CocktailIds A list of cocktail IDs to publish
	CocktailIds []string `json:"cocktailIds"`
}

// UofMTypeModel The unit of measure when using this ingredient in a cocktail recipe
type UofMTypeModel = interface{}

// SeedCocktailsParams defines parameters for SeedCocktails.
type SeedCocktailsParams struct {
	// XKey Subscription key
	XKey *string `json:"X-Key,omitempty"`
}

// PublishCocktailsParams defines parameters for PublishCocktails.
type PublishCocktailsParams struct {
	// XKey Subscription key
	XKey *string `json:"X-Key,omitempty"`
}

// SeedIngredientsParams defines parameters for SeedIngredients.
type SeedIngredientsParams struct {
	// XKey Subscription key
	XKey *string `json:"X-Key,omitempty"`
}

// GetCocktailIngredientFiltersParams defines parameters for GetCocktailIngredientFilters.
type GetCocktailIngredientFiltersParams struct {
	// XKey Subscription key
	XKey *string `json:"X-Key,omitempty"`
}

// GetCocktailParams defines parameters for GetCocktail.
type GetCocktailParams struct {
	// XKey Subscription key
	XKey *string `json:"X-Key,omitempty"`
}

// GetPrivacyPolicyParams defines parameters for GetPrivacyPolicy.
type GetPrivacyPolicyParams struct {
	// XKey Subscription key
	XKey *string `json:"X-Key,omitempty"`
}

// GetTermsOfServiceParams defines parameters for GetTermsOfService.
type GetTermsOfServiceParams struct {
	// XKey Subscription key
	XKey *string `json:"X-Key,omitempty"`
}

// InitParams defines parameters for Init.
type InitParams struct {
	// XKey Subscription key
	XKey *string `json:"X-Key,omitempty"`
}

// PublishCocktailsApplicationJSONXAPIVersion10RequestBody defines body for PublishCocktails for application/json; x-api-version=1.0 ContentType.
type PublishCocktailsApplicationJSONXAPIVersion10RequestBody = PublishCocktailsRq

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// SeedCocktails request
	SeedCocktails(ctx context.Context, params *SeedCocktailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PublishCocktailsWithBody request with any body
	PublishCocktailsWithBody(ctx context.Context, params *PublishCocktailsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PublishCocktailsWithApplicationJSONXAPIVersion10Body(ctx context.Context, params *PublishCocktailsParams, body PublishCocktailsApplicationJSONXAPIVersion10RequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SeedIngredients request
	SeedIngredients(ctx context.Context, params *SeedIngredientsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCocktailIngredientFilters request
	GetCocktailIngredientFilters(ctx context.Context, params *GetCocktailIngredientFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCocktail request
	GetCocktail(ctx context.Context, id string, params *GetCocktailParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPrivacyPolicy request
	GetPrivacyPolicy(ctx context.Context, params *GetPrivacyPolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTermsOfService request
	GetTermsOfService(ctx context.Context, params *GetTermsOfServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Init request
	Init(ctx context.Context, params *InitParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) SeedCocktails(ctx context.Context, params *SeedCocktailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSeedCocktailsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublishCocktailsWithBody(ctx context.Context, params *PublishCocktailsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublishCocktailsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublishCocktailsWithApplicationJSONXAPIVersion10Body(ctx context.Context, params *PublishCocktailsParams, body PublishCocktailsApplicationJSONXAPIVersion10RequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublishCocktailsRequestWithApplicationJSONXAPIVersion10Body(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SeedIngredients(ctx context.Context, params *SeedIngredientsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSeedIngredientsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCocktailIngredientFilters(ctx context.Context, params *GetCocktailIngredientFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCocktailIngredientFiltersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCocktail(ctx context.Context, id string, params *GetCocktailParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCocktailRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPrivacyPolicy(ctx context.Context, params *GetPrivacyPolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPrivacyPolicyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTermsOfService(ctx context.Context, params *GetTermsOfServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTermsOfServiceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Init(ctx context.Context, params *InitParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInitRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewSeedCocktailsRequest generates requests for SeedCocktails
func NewSeedCocktailsRequest(server string, params *SeedCocktailsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cocktails")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Key", runtime.ParamLocationHeader, *params.XKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Key", headerParam0)
		}

	}

	return req, nil
}

// NewPublishCocktailsRequestWithApplicationJSONXAPIVersion10Body calls the generic PublishCocktails builder with application/json; x-api-version=1.0 body
func NewPublishCocktailsRequestWithApplicationJSONXAPIVersion10Body(server string, params *PublishCocktailsParams, body PublishCocktailsApplicationJSONXAPIVersion10RequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPublishCocktailsRequestWithBody(server, params, "application/json; x-api-version=1.0", bodyReader)
}

// NewPublishCocktailsRequestWithBody generates requests for PublishCocktails with any type of body
func NewPublishCocktailsRequestWithBody(server string, params *PublishCocktailsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cocktails/admin/pub")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Key", runtime.ParamLocationHeader, *params.XKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Key", headerParam0)
		}

	}

	return req, nil
}

// NewSeedIngredientsRequest generates requests for SeedIngredients
func NewSeedIngredientsRequest(server string, params *SeedIngredientsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cocktails/ingredients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Key", runtime.ParamLocationHeader, *params.XKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Key", headerParam0)
		}

	}

	return req, nil
}

// NewGetCocktailIngredientFiltersRequest generates requests for GetCocktailIngredientFilters
func NewGetCocktailIngredientFiltersRequest(server string, params *GetCocktailIngredientFiltersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cocktails/ingredients/filters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Key", runtime.ParamLocationHeader, *params.XKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Key", headerParam0)
		}

	}

	return req, nil
}

// NewGetCocktailRequest generates requests for GetCocktail
func NewGetCocktailRequest(server string, id string, params *GetCocktailParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cocktails/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Key", runtime.ParamLocationHeader, *params.XKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Key", headerParam0)
		}

	}

	return req, nil
}

// NewGetPrivacyPolicyRequest generates requests for GetPrivacyPolicy
func NewGetPrivacyPolicyRequest(server string, params *GetPrivacyPolicyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/legal/documents/privacy-policy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Key", runtime.ParamLocationHeader, *params.XKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Key", headerParam0)
		}

	}

	return req, nil
}

// NewGetTermsOfServiceRequest generates requests for GetTermsOfService
func NewGetTermsOfServiceRequest(server string, params *GetTermsOfServiceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/legal/documents/terms-of-service")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Key", runtime.ParamLocationHeader, *params.XKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Key", headerParam0)
		}

	}

	return req, nil
}

// NewInitRequest generates requests for Init
func NewInitRequest(server string, params *InitParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/job/initialize-app")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Key", runtime.ParamLocationHeader, *params.XKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Key", headerParam0)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// SeedCocktailsWithResponse request
	SeedCocktailsWithResponse(ctx context.Context, params *SeedCocktailsParams, reqEditors ...RequestEditorFn) (*SeedCocktailsResponse, error)

	// PublishCocktailsWithBodyWithResponse request with any body
	PublishCocktailsWithBodyWithResponse(ctx context.Context, params *PublishCocktailsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PublishCocktailsResponse, error)

	PublishCocktailsWithApplicationJSONXAPIVersion10BodyWithResponse(ctx context.Context, params *PublishCocktailsParams, body PublishCocktailsApplicationJSONXAPIVersion10RequestBody, reqEditors ...RequestEditorFn) (*PublishCocktailsResponse, error)

	// SeedIngredientsWithResponse request
	SeedIngredientsWithResponse(ctx context.Context, params *SeedIngredientsParams, reqEditors ...RequestEditorFn) (*SeedIngredientsResponse, error)

	// GetCocktailIngredientFiltersWithResponse request
	GetCocktailIngredientFiltersWithResponse(ctx context.Context, params *GetCocktailIngredientFiltersParams, reqEditors ...RequestEditorFn) (*GetCocktailIngredientFiltersResponse, error)

	// GetCocktailWithResponse request
	GetCocktailWithResponse(ctx context.Context, id string, params *GetCocktailParams, reqEditors ...RequestEditorFn) (*GetCocktailResponse, error)

	// GetPrivacyPolicyWithResponse request
	GetPrivacyPolicyWithResponse(ctx context.Context, params *GetPrivacyPolicyParams, reqEditors ...RequestEditorFn) (*GetPrivacyPolicyResponse, error)

	// GetTermsOfServiceWithResponse request
	GetTermsOfServiceWithResponse(ctx context.Context, params *GetTermsOfServiceParams, reqEditors ...RequestEditorFn) (*GetTermsOfServiceResponse, error)

	// InitWithResponse request
	InitWithResponse(ctx context.Context, params *InitParams, reqEditors ...RequestEditorFn) (*InitResponse, error)
}

type SeedCocktailsResponse struct {
	Body                                []byte
	HTTPResponse                        *http.Response
	ApplicationjsonXApiVersion10Default *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r SeedCocktailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SeedCocktailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PublishCocktailsResponse struct {
	Body                                []byte
	HTTPResponse                        *http.Response
	ApplicationjsonXApiVersion10Default *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r PublishCocktailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PublishCocktailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SeedIngredientsResponse struct {
	Body                                []byte
	HTTPResponse                        *http.Response
	ApplicationjsonXApiVersion10Default *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r SeedIngredientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SeedIngredientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCocktailIngredientFiltersResponse struct {
	Body                                []byte
	HTTPResponse                        *http.Response
	ApplicationjsonXApiVersion10200     *CocktailIngredientFiltersRs
	ApplicationjsonXApiVersion10Default *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetCocktailIngredientFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCocktailIngredientFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCocktailResponse struct {
	Body                                []byte
	HTTPResponse                        *http.Response
	ApplicationjsonXApiVersion10200     *CocktailRs
	ApplicationjsonXApiVersion10Default *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetCocktailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCocktailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPrivacyPolicyResponse struct {
	Body                                []byte
	HTTPResponse                        *http.Response
	ApplicationjsonXApiVersion10200     *LegalDocumentRs
	ApplicationjsonXApiVersion10Default *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetPrivacyPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPrivacyPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTermsOfServiceResponse struct {
	Body                                []byte
	HTTPResponse                        *http.Response
	ApplicationjsonXApiVersion10200     *LegalDocumentRs
	ApplicationjsonXApiVersion10Default *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetTermsOfServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTermsOfServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// SeedCocktailsWithResponse request returning *SeedCocktailsResponse
func (c *ClientWithResponses) SeedCocktailsWithResponse(ctx context.Context, params *SeedCocktailsParams, reqEditors ...RequestEditorFn) (*SeedCocktailsResponse, error) {
	rsp, err := c.SeedCocktails(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSeedCocktailsResponse(rsp)
}

// PublishCocktailsWithBodyWithResponse request with arbitrary body returning *PublishCocktailsResponse
func (c *ClientWithResponses) PublishCocktailsWithBodyWithResponse(ctx context.Context, params *PublishCocktailsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PublishCocktailsResponse, error) {
	rsp, err := c.PublishCocktailsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublishCocktailsResponse(rsp)
}

func (c *ClientWithResponses) PublishCocktailsWithApplicationJSONXAPIVersion10BodyWithResponse(ctx context.Context, params *PublishCocktailsParams, body PublishCocktailsApplicationJSONXAPIVersion10RequestBody, reqEditors ...RequestEditorFn) (*PublishCocktailsResponse, error) {
	rsp, err := c.PublishCocktailsWithApplicationJSONXAPIVersion10Body(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublishCocktailsResponse(rsp)
}

// SeedIngredientsWithResponse request returning *SeedIngredientsResponse
func (c *ClientWithResponses) SeedIngredientsWithResponse(ctx context.Context, params *SeedIngredientsParams, reqEditors ...RequestEditorFn) (*SeedIngredientsResponse, error) {
	rsp, err := c.SeedIngredients(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSeedIngredientsResponse(rsp)
}

// GetCocktailIngredientFiltersWithResponse request returning *GetCocktailIngredientFiltersResponse
func (c *ClientWithResponses) GetCocktailIngredientFiltersWithResponse(ctx context.Context, params *GetCocktailIngredientFiltersParams, reqEditors ...RequestEditorFn) (*GetCocktailIngredientFiltersResponse, error) {
	rsp, err := c.GetCocktailIngredientFilters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCocktailIngredientFiltersResponse(rsp)
}

// GetCocktailWithResponse request returning *GetCocktailResponse
func (c *ClientWithResponses) GetCocktailWithResponse(ctx context.Context, id string, params *GetCocktailParams, reqEditors ...RequestEditorFn) (*GetCocktailResponse, error) {
	rsp, err := c.GetCocktail(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCocktailResponse(rsp)
}

// GetPrivacyPolicyWithResponse request returning *GetPrivacyPolicyResponse
func (c *ClientWithResponses) GetPrivacyPolicyWithResponse(ctx context.Context, params *GetPrivacyPolicyParams, reqEditors ...RequestEditorFn) (*GetPrivacyPolicyResponse, error) {
	rsp, err := c.GetPrivacyPolicy(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPrivacyPolicyResponse(rsp)
}

// GetTermsOfServiceWithResponse request returning *GetTermsOfServiceResponse
func (c *ClientWithResponses) GetTermsOfServiceWithResponse(ctx context.Context, params *GetTermsOfServiceParams, reqEditors ...RequestEditorFn) (*GetTermsOfServiceResponse, error) {
	rsp, err := c.GetTermsOfService(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTermsOfServiceResponse(rsp)
}

// InitWithResponse request returning *InitResponse
func (c *ClientWithResponses) InitWithResponse(ctx context.Context, params *InitParams, reqEditors ...RequestEditorFn) (*InitResponse, error) {
	rsp, err := c.Init(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInitResponse(rsp)
}

// ParseSeedCocktailsResponse parses an HTTP response from a SeedCocktailsWithResponse call
func ParseSeedCocktailsResponse(rsp *http.Response) (*SeedCocktailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SeedCocktailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonXApiVersion10Default = &dest

	}

	return response, nil
}

// ParsePublishCocktailsResponse parses an HTTP response from a PublishCocktailsWithResponse call
func ParsePublishCocktailsResponse(rsp *http.Response) (*PublishCocktailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PublishCocktailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonXApiVersion10Default = &dest

	}

	return response, nil
}

// ParseSeedIngredientsResponse parses an HTTP response from a SeedIngredientsWithResponse call
func ParseSeedIngredientsResponse(rsp *http.Response) (*SeedIngredientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SeedIngredientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonXApiVersion10Default = &dest

	}

	return response, nil
}

// ParseGetCocktailIngredientFiltersResponse parses an HTTP response from a GetCocktailIngredientFiltersWithResponse call
func ParseGetCocktailIngredientFiltersResponse(rsp *http.Response) (*GetCocktailIngredientFiltersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCocktailIngredientFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CocktailIngredientFiltersRs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonXApiVersion10200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonXApiVersion10Default = &dest

	}

	return response, nil
}

// ParseGetCocktailResponse parses an HTTP response from a GetCocktailWithResponse call
func ParseGetCocktailResponse(rsp *http.Response) (*GetCocktailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCocktailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CocktailRs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonXApiVersion10200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonXApiVersion10Default = &dest

	}

	return response, nil
}

// ParseGetPrivacyPolicyResponse parses an HTTP response from a GetPrivacyPolicyWithResponse call
func ParseGetPrivacyPolicyResponse(rsp *http.Response) (*GetPrivacyPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPrivacyPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LegalDocumentRs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonXApiVersion10200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonXApiVersion10Default = &dest

	}

	return response, nil
}

// ParseGetTermsOfServiceResponse parses an HTTP response from a GetTermsOfServiceWithResponse call
func ParseGetTermsOfServiceResponse(rsp *http.Response) (*GetTermsOfServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTermsOfServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LegalDocumentRs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonXApiVersion10200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonXApiVersion10Default = &dest

	}

	return response, nil
}

// ParseInitResponse parses an HTTP response from a InitWithResponse call
func ParseInitResponse(rsp *http.Response) (*InitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}
